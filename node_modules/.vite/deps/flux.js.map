{
  "version": 3,
  "sources": ["../../fbjs/lib/invariant.js", "../../flux/lib/Dispatcher.js", "../../flux/index.js"],
  "sourcesContent": ["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n'use strict';\n\nvar validateFormat = process.env.NODE_ENV !== \"production\" ? function (format) {\n  if (format === undefined) {\n    throw new Error('invariant(...): Second argument must be a string.');\n  }\n} : function (format) {};\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments to provide\n * information about what broke and what you were expecting.\n *\n * The invariant message will be stripped in production, but the invariant will\n * remain to ensure logic does not differ in production.\n */\n\nfunction invariant(condition, format) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return String(args[argIndex++]);\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // Skip invariant's own stack frame.\n\n    throw error;\n  }\n}\n\nmodule.exports = invariant;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Dispatcher\n * \n * @preventMunge\n */\n\n'use strict';\n\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar invariant = require(\"fbjs/lib/invariant\");\nvar _prefix = 'ID_';\n\n/**\n * Dispatcher is used to broadcast payloads to registered callbacks. This is\n * different from generic pub-sub systems in two ways:\n *\n *   1) Callbacks are not subscribed to particular events. Every payload is\n *      dispatched to every registered callback.\n *   2) Callbacks can be deferred in whole or part until other callbacks have\n *      been executed.\n *\n * For example, consider this hypothetical flight destination form, which\n * selects a default city when a country is selected:\n *\n *   var flightDispatcher = new Dispatcher();\n *\n *   // Keeps track of which country is selected\n *   var CountryStore = {country: null};\n *\n *   // Keeps track of which city is selected\n *   var CityStore = {city: null};\n *\n *   // Keeps track of the base flight price of the selected city\n *   var FlightPriceStore = {price: null}\n *\n * When a user changes the selected city, we dispatch the payload:\n *\n *   flightDispatcher.dispatch({\n *     actionType: 'city-update',\n *     selectedCity: 'paris'\n *   });\n *\n * This payload is digested by `CityStore`:\n *\n *   flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'city-update') {\n *       CityStore.city = payload.selectedCity;\n *     }\n *   });\n *\n * When the user selects a country, we dispatch the payload:\n *\n *   flightDispatcher.dispatch({\n *     actionType: 'country-update',\n *     selectedCountry: 'australia'\n *   });\n *\n * This payload is digested by both stores:\n *\n *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'country-update') {\n *       CountryStore.country = payload.selectedCountry;\n *     }\n *   });\n *\n * When the callback to update `CountryStore` is registered, we save a reference\n * to the returned token. Using this token with `waitFor()`, we can guarantee\n * that `CountryStore` is updated before the callback that updates `CityStore`\n * needs to query its data.\n *\n *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'country-update') {\n *       // `CountryStore.country` may not be updated.\n *       flightDispatcher.waitFor([CountryStore.dispatchToken]);\n *       // `CountryStore.country` is now guaranteed to be updated.\n *\n *       // Select the default city for the new country\n *       CityStore.city = getDefaultCityForCountry(CountryStore.country);\n *     }\n *   });\n *\n * The usage of `waitFor()` can be chained, for example:\n *\n *   FlightPriceStore.dispatchToken =\n *     flightDispatcher.register(function(payload) {\n *       switch (payload.actionType) {\n *         case 'country-update':\n *         case 'city-update':\n *           flightDispatcher.waitFor([CityStore.dispatchToken]);\n *           FlightPriceStore.price =\n *             getFlightPriceStore(CountryStore.country, CityStore.city);\n *           break;\n *     }\n *   });\n *\n * The `country-update` payload will be guaranteed to invoke the stores'\n * registered callbacks in order: `CountryStore`, `CityStore`, then\n * `FlightPriceStore`.\n */\nvar Dispatcher = /*#__PURE__*/function () {\n  function Dispatcher() {\n    _defineProperty(this, \"_callbacks\", void 0);\n    _defineProperty(this, \"_isDispatching\", void 0);\n    _defineProperty(this, \"_isHandled\", void 0);\n    _defineProperty(this, \"_isPending\", void 0);\n    _defineProperty(this, \"_lastID\", void 0);\n    _defineProperty(this, \"_pendingPayload\", void 0);\n    this._callbacks = {};\n    this._isDispatching = false;\n    this._isHandled = {};\n    this._isPending = {};\n    this._lastID = 1;\n  }\n\n  /**\n   * Registers a callback to be invoked with every dispatched payload. Returns\n   * a token that can be used with `waitFor()`.\n   */\n  var _proto = Dispatcher.prototype;\n  _proto.register = function register(callback) {\n    var id = _prefix + this._lastID++;\n    this._callbacks[id] = callback;\n    return id;\n  }\n\n  /**\n   * Removes a callback based on its token.\n   */;\n  _proto.unregister = function unregister(id) {\n    !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n    delete this._callbacks[id];\n  }\n\n  /**\n   * Waits for the callbacks specified to be invoked before continuing execution\n   * of the current callback. This method should only be used by a callback in\n   * response to a dispatched payload.\n   */;\n  _proto.waitFor = function waitFor(ids) {\n    !this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : void 0;\n    for (var ii = 0; ii < ids.length; ii++) {\n      var id = ids[ii];\n      if (this._isPending[id]) {\n        !this._isHandled[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : void 0;\n        continue;\n      }\n      !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n      this._invokeCallback(id);\n    }\n  }\n\n  /**\n   * Dispatches a payload to all registered callbacks.\n   */;\n  _proto.dispatch = function dispatch(payload) {\n    !!this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : void 0;\n    this._startDispatching(payload);\n    try {\n      for (var id in this._callbacks) {\n        if (this._isPending[id]) {\n          continue;\n        }\n        this._invokeCallback(id);\n      }\n    } finally {\n      this._stopDispatching();\n    }\n  }\n\n  /**\n   * Is this Dispatcher currently dispatching.\n   */;\n  _proto.isDispatching = function isDispatching() {\n    return this._isDispatching;\n  }\n\n  /**\n   * Call the callback stored with the given id. Also do some internal\n   * bookkeeping.\n   *\n   * @internal\n   */;\n  _proto._invokeCallback = function _invokeCallback(id) {\n    this._isPending[id] = true;\n    this._callbacks[id](this._pendingPayload);\n    this._isHandled[id] = true;\n  }\n\n  /**\n   * Set up bookkeeping needed when dispatching.\n   *\n   * @internal\n   */;\n  _proto._startDispatching = function _startDispatching(payload) {\n    for (var id in this._callbacks) {\n      this._isPending[id] = false;\n      this._isHandled[id] = false;\n    }\n    this._pendingPayload = payload;\n    this._isDispatching = true;\n  }\n\n  /**\n   * Clear bookkeeping used for dispatching.\n   *\n   * @internal\n   */;\n  _proto._stopDispatching = function _stopDispatching() {\n    delete this._pendingPayload;\n    this._isDispatching = false;\n  };\n  return Dispatcher;\n}();\nmodule.exports = Dispatcher;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nmodule.exports.Dispatcher = require('./lib/Dispatcher');\n"],
  "mappings": "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",
  "names": ["Dispatcher"]
}
